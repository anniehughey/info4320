// TimerOne - Version: Latest #include <TimerOne.h>// StepperRobot - Version: Latest #include <StepperMotor.h>#include <StepperRobot.h>#include <stpCircBuff.h>// NewPing - Version: Latest #include "NewPing.h"#include "Stepper.h"#include "NewTone.h"// movement types#define mvAhead 0#define mvBack 1#define mvSpinL 2#define mvSpinR 3#define mvTurnL 4#define mvTurnR 5#define mvBkTurnL 6#define mvBkTurnR 7#define mvBrake 8// revolution#define stepsPerRevolution 48#define startSpeed 72#define cruiseSpeed 182#define pulsesToCruise 110//volume sonar//const int V_trigPin = 10;//const int V_echoPin = 9;// pitch sonar//const int P_trigPin = 3;//const int P_echoPin = 5;const int avoidancePin = PIN;const int avoidanceLedPin = PIN;const int buzzer = 1;// sonarsNewPing volumeSonar(9, 10, 500);NewPing pitchSonar(3, 5, 500);int counter = 0;long V_duration, P_duration, duration;int V_distance, P_distance, P_distance1, P_distance2;int sound = 250;int V_array[1];int val;int x;// 1000000/(STEPS_PER_TURN*RotationSpeed/60.0)const int delay_between_step_microsec = 5000;// variable to read the value from the analog pinint val;void setup() {  pinMode(V_trigPin, OUTPUT);  pinMode(V_echoPin, INPUT);  pinMode(P_trigPin, OUTPUT);  pinMode(P_echoPin, INPUT);  pinMode(buzzer, OUTPUT);  pinMode(avoidancePin, INPUT);  pinMode(avoidanceLedPin, OUTPUT);  rob.init(startSpeed, cruiseSpeed, pulsesToCruise);   rob.initRightMotor(4,5,6,7);   rob.initLeftMotor(9,10,11,12);  Serial.begin(9600);}int change(int distance1, int distance2){  int delta =  distance2 - distance1;   Serial.println("change");  Serial.println(delta);  if(delta != 0){    return delta;  }else{    Serial.println("NO CHANGE!");    return 0;  }}void loop() {  // avoidance  val = digitalRead(avoidancePin) ;// digital interface will be assigned a value of 3 to read val  if (val == LOW) // When the obstacle avoidance sensor detects a signal, LED flashes  {    digitalWrite(avoidanceLedPin, LOW); //turn off the led        // begin sonars    P_distance1 = pitchSonar.convert_cm(pitchSonar.ping_median(20));    V_distance1 = volumeSonar.convert_cm(volumeSonar.ping_median(20));    delay(1000);    Serial.println("Volume Sonar Distance 1: ");    Serial.println(V_distance1);    Serial.println("Pitch Sonar Distance 1: ");    Serial.println(P_distance1);    P_distance2 = pitchSonar.convert_cm(pitchSonar.ping_median(20));    V_distance2 = volumeSonar.convert_cm(volumeSonar.ping_median(20));    Serial.println("Volume Sonar Distance 2: ");    Serial.println(V_distance2);    Serial.println("Pitch Sonar Distance 2: ");    Serial.println(P_distance2);    int P_change = change(P_distance1, P_distance2);    int V_change = change(V_distance1, V_distance2);        // fwd turns, volume sonar distance decreasing    if(V_change < -2){      // CASE 1: pitch sonar distance desceasing       if(P_change < -2){        Serial.println("FORWARD RIGHT TURN");        rob.addMove(mvTurnR, turnPulses/2);      }      // CASE 2: pitch sonar distance desceasing       else if(P_change > 2){        Serial.println("FORWARD LEFT TURN");        rob.addMove(mvTurnL, turnPulses/2);      }      // CASE 3: steady or stable pitch sonar      else {        Serial.println("FORWARD STRAIGHT");        rob.addMove(mvAhead, stepsPerRevolution*5);      }    }    // bkwd turns, volume sonar distance increasing    else if(V_change > 2){      // CASE 4: pitch sonar distance desceasing       if(P_change < -2){        Serial.println("BACKWARD RIGHT TURN");        rob.addMove(mvBkTurnR, turnPulses/2);      }      // CASE 5: pitch sonar distance desceasing       else if(P_change > 2){        Serial.println("BACKWARD LEFT TURN");        rob.addMove(mvBKTurnL, turnPulses/2);      }      // CASE 6: steady or stable pitch sonar      else {        Serial.println("BACKWARD STRAIGHT");        rob.addMove(mvBack, stepsPerRevolution*5);      }    } else{      //CASE 7: steady volume, increasing pitch      if(P_change > 2){        Serial.println("LEFT SPIN");        rob.addMove(mvSpinL, spinPulses*2);      }      //CASE 8: steady volume, decreasing pitch      else if(P_change < -2){        Serial.println("RIGHT SPIN");        rob.addMove(mvSpinR, spinPulses*2);      }      //CASE 9: steady volume, steady pitch      else{        Serial.println("REST");        rob.addMove(mvBrake, startSpeed*5);      }    }        if(V_distance1 == 0 || V_distance2 == 0){      Serial.println("Object very far away!!");    }    if(P_distance1 == 0 || P_distance2 == 0){      Serial.println("Object very far away!!");    }    // map the sensor values to G3-F5: http://peabody.sapp.org/class/st2/lab/notehz/    int pitch = map(P_distance, 3, 50, 196, 700);      NewTone(4, pitch);    }    // avoidance triggered    else{      digitalWrite(avoidanceLedPin, HIGH); //turn on the led      Serial.println("OBJECT INFRONT OF ROBOT");      rob.addMove(mvTurnL, spinPulses*2);    }    // Start execution  rob.goNow();}